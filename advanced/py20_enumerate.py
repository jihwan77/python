# enumerate와 문자열 비교

# 정렬하고 번호를 매겨서 딕셔너리로 저장

# 문자열을 비교 정렬하고 문자열을 비교
# 번호를 매겨서
# 딕셔너리에 저장

# 문자열 비교
print('A' < 'Z') # 알파벳 순서상 뒤로 갈수록 크다
print('AA' < 'AZ') # 첫번째 문자가 같다면 두 번째 문자를 비교한다.
print('AA' < 'AAA') # 비교하는 문자들이 모두 같다면, 하나라도 긴 문자열이 크다
print('A' < 'a') # 소문자가 대문자보다 크다

print('가' < '나') # 가나다 순으로 뒤로 갈수록 크다
print('가' < '구') # 아야어여오요우유으이 순으로 뒤로 갈수록 크다
print('가가' < '가나') # 첫번째 문자가 같다면 두 번째 문자를 비교한다.
print('하하' < '하하하') # 비교하는 문자들이 모두 같다면, 하나라도 긴 문자열이 크다

names = ['윤나은', '김현주', '장현지', '이지선', '박선주']
# sort() 함수로 정렬
names.sort()
print(names) # ['김현주', '박선주', '윤나은', '이지선', '장현지']
dnames = {}
i = 1
for n in names:
  dnames[i] = n # i와 n을 각각 key, value로 해서 딕셔너리에 저장
  i += 1
print(dnames) # {1: '김현주', 2: '박선주', 3: '윤나은', 4: '이지선', 5: '장현지'}

# enumerate 
names = ['윤나은', '김현주', '장현지', '이지선', '박선주']
# 기능 : 넘버링
# enumerate함수는 enumerate객체라는 iterator객체를 생성
# 컴프리핸션를 사용하기 어려운 상황에서 사용할 수 있게 하는 매력이 있음
eo = enumerate(names) # iterator객체인 enumerate객체생성
for n in eo:
  print(n) # (0, '윤나은')(1, '김현주')...(4, '박선주')

eo = enumerate(names, 10) # 번호를 10부터 매기기 시작
for n in eo:
  print(n) # (10, '윤나은')(11, '김현주')...(14, '박선주')

# 정렬하고 번호를 매겨서 딕셔너리로 저장하는 복잡한 기능을 한줄로 간단히 작성 가능
# enumerate 함수를 사용한 것도 의미가 있지만 딕셔너리 컴프리헨션을 사용할 수 있게 되었다는데 더 큰 의미가 있다
dnames = {k : v for k, v in enumerate(sorted(names), 1)}
print(dnames) # {1: '김현주', 2: '박선주', 3: '윤나은', 4: '이지선', 5: '장현지'}